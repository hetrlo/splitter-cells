"""
An analysis of the bot's trajectory, to quantify its exploration of the maze

"""

import numpy as np
import matplotlib.pyplot as plt
from math import *

def load_positions(path):
    return np.load(path + 'positions.npy')


def load_reservoir_states(path):
    return np.load(path + 'reservoir_states.npy')


def load_orientations(path):
    return np.load(path + 'output.npy')

def load_sensors(path):
    return np.load(path + 'input.npy')

# Computes the percentage of time the bot touches the walls
def walls_collision_percentage():
    sensitivity = 0.05 # sensitivity of the sensors

    path = "/home/heloise/Mnémosyne/splitter-cells/trials/states/"
    sensors = load_sensors(path)
    len_record = len(sensors)

    # Determins wether the bot was in a wall at a given step
    def is_collision(sensors_values):
        collision = False
        for i in range(len(sensors_values)):
            collision = collision or (sensors_values[i] < sensitivity)
        return collision
    
    collision = np.array([is_collision(sensors[i]) for i in range(len_record)])
    nb_collisions = np.count_nonzero(collision)
    return (nb_collisions / len_record) * 100

# Determins how uniformely the bot explores the maze
def exploratory_rate(resolution):
    movement_repartition = np.zeros(resolution)
    path = "/home/heloise/Mnémosyne/splitter-cells/trials/states/"
    positions = load_positions(path)
    len_record = len(positions)

    for i in range(len_record):
        # Computing correspondance between position and indexes in the repartition matrix
        x = floor((positions[i][0] / 300) * resolution[0])
        y = floor((positions[i][1] / 500) * resolution[1])
        movement_repartition[x,y] += 1
    
    # Normalizing the array
    movement_repartition /= np.std(movement_repartition)

    plt.imshow(movement_repartition.T, cmap='inferno', origin='lower')
    plt.show()